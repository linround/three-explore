uniform float iTime;
uniform vec3 iResolution;
uniform vec2 iMouse;



// 这里 x y 差值范围在[-0.02 , 0.02] 之间的值，会返回一个平滑值
// 相差在 范围之外的 返回的是1这个值


// 这里传入的是一个绝对值
// 所以xy绝对值在范围内时，取得范围内的一个 差值结果；
// 在范围外时（也就是一定大于上边界），取得的结果时 1；
// 这是一个线性差值

// 这里直接使用传入的坐标来计算 该坐标的 目标颜色比重
float plot(vec2 st){
    return smoothstep(0.01,0.0,abs(st.y-st.x));
}

void main() {
    vec2 st = gl_FragCoord.xy / iResolution.xy;
    // 这是准备绘制的曲线
    float y = st.x;


    vec3 color = vec3(y);
    //
    float pct = plot(st);// 结果在[0,1]之间

    // 这里也相当于
    // 这里也证明了在计算过程中 向量运算是可以有负值的
    // 但是在最终显示颜色的时候 负值被认为是零，大于1的被认为时1；

    // 三个点
    // 下边界大于上边界 1
    // （0.5，0.0）   smooth(0.02,0.0,-0.5)     1     => 1
    // （0.5，0.5）    smooth(0.02,0.0,0.0)     1     => 1
    // （0.5，1.0）   smooth(0.02,0.0,0.5)      0     => 0


    // 取绝对值 2
    // （0.5，0.0）   smooth(0.02,0.0,0.5)      0     => 0
    // （0.5，0.5）    smooth(0.02,0.0,0.0)     1     => 1
    // （0.5，1.0）   smooth(0.02,0.0,0.5)      0     => 0



    // 如果下边界小于上边界  3
    // （0.5，0.0）   smooth(0.0,0.02,-0.5)     1     => 0
    // （0.5，0.5）    smooth(0.0,0.02,0.0)     0     => 0
    // （0.5，1.0）   smooth(0.0,0.02,0.5)      0     => 1

    // 取绝对值 4
    // （0.5，0.0）   smooth(0.0,0.02,0.5)      1     => 1
    // （0.5，0.5）    smooth(0.0,0.02,0.0)     0     => 0
    // （0.5，1.0）   smooth(0.0,0.02,0.5)      1     => 1



    // 由上可见 组合 （0，1，0）的几种方式
    // 一. 2
    // 二. 2-3
    // 三. 2-4
    // 四. 1-4




    // vec3(1.0,0.0,0.0) - color 这里计算结果包含了负值
    // pct 即在红线范围以外的差值都是1，在红线范围以内的会使用差值方程进行计算

    // 以上由于交换了上下边界的大小 可观察 smoostep函数
    // pct 此时 在红线范围内 为差值结果，在红线范围外为1
    // 所以红线范围外的只有背景色


    // 最终可以看作是颜色的一个混合
    // 红线范围内的 就是 差值结果 + 背景色
    // 越靠近中心点 插值结果越接近目标颜色
    // 远离中心点会慢慢的加重背景色的比重，减少目标色比重
    color = (1.0-pct)*color + pct * vec3(1.0,0.0,0.0);

    gl_FragColor=vec4(color,1.0);
}
